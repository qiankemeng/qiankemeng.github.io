/**
 * Markdown Generator
 * ç”Ÿæˆåšå®¢æ–‡ç« çš„Markdownæ–‡ä»¶
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { config } from './config.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

/**
 * ç”ŸæˆURLå‹å¥½çš„slug
 */
function generateSlug(title, arxivId) {
  // ä»arXiv IDç”Ÿæˆç®€æ´çš„slug
  const cleanId = arxivId.replace(/\./g, '');
  const date = new Date().toISOString().split('T')[0];
  return `arxiv-${cleanId}-${date}`;
}

/**
 * ç”Ÿæˆä¸­æ–‡Markdownæ–‡ä»¶å†…å®¹
 */
function generateChineseMarkdown(paper) {
  const { categoryMap } = config;
  const tags = [
    ...paper.suggestedTags,
    ...paper.categories.map(cat => categoryMap[cat]).filter(Boolean),
    'arXiv',
    'AIç²¾é€‰'
  ];

  // å»é‡
  const uniqueTags = [...new Set(tags)];

  const frontmatter = `---
title: "${paper.title}"
date: "${paper.published}"
summary: "${paper.summary.substring(0, 200).replace(/"/g, '\\"')}..."
tags: ${JSON.stringify(uniqueTags)}
venue: "arXiv Preprint"
status: "preprint"
authors:
${paper.authors.map(name => `  - name: "${name}"`).join('\n')}
arxiv: "${paper.arxivUrl}"
pdf: "${paper.pdfUrl}"
${paper.github ? `github: "${paper.github}"` : ''}
ai_generated: true
filter_score: ${paper.filterScore}
---`;

  const content = `
# ${paper.title}

> ğŸ“„ è®ºæ–‡é“¾æ¥: [arXiv](${paper.arxivUrl}) | [PDF](${paper.pdfUrl})
${paper.github ? `> ğŸ’» ä»£ç ä»“åº“: [GitHub](${paper.github})` : ''}
> ğŸ¤– æœ¬æ–‡ç”±AIè‡ªåŠ¨ç­›é€‰å’Œæ€»ç»“ï¼Œå†…å®¹ä»…ä¾›å‚è€ƒ

---

## AI ç­›é€‰ç†ç”±

${paper.filterReason}

**ç›¸å…³åº¦è¯„åˆ†**: ${paper.filterScore}/10

---

${paper.summary_zh || '## è®ºæ–‡æ‘˜è¦\n\n' + paper.summary}

---

## åŸå§‹æ‘˜è¦ (English)

${paper.summary}

---

## è®ºæ–‡ä¿¡æ¯

- **arXiv ID**: ${paper.arxivId}
- **å‘å¸ƒæ—¥æœŸ**: ${paper.published}
- **æ›´æ–°æ—¥æœŸ**: ${paper.updated}
- **åˆ†ç±»**: ${paper.categories.join(', ')}
- **ä½œè€…**: ${paper.authors.join(', ')}

---

*æœ¬æ–‡ç”±AI Agentè‡ªåŠ¨ç”Ÿæˆäº ${new Date().toISOString().split('T')[0]}ã€‚å¦‚æœ‰ç†è§£åå·®ï¼Œè¯·ä»¥åŸè®ºæ–‡ä¸ºå‡†ã€‚*
`;

  return frontmatter + '\n' + content;
}

/**
 * ç”Ÿæˆè‹±æ–‡Markdownæ–‡ä»¶å†…å®¹
 */
function generateEnglishMarkdown(paper) {
  const { categoryMap } = config;
  const tags = [
    ...paper.suggestedTags,
    ...paper.categories,
    'arXiv',
    'AI Curated'
  ];

  const uniqueTags = [...new Set(tags)];

  const frontmatter = `---
title: "${paper.title}"
date: "${paper.published}"
summary: "${paper.summary.substring(0, 200).replace(/"/g, '\\"')}..."
tags: ${JSON.stringify(uniqueTags)}
venue: "arXiv Preprint"
status: "preprint"
authors:
${paper.authors.map(name => `  - name: "${name}"`).join('\n')}
arxiv: "${paper.arxivUrl}"
pdf: "${paper.pdfUrl}"
${paper.github ? `github: "${paper.github}"` : ''}
ai_generated: true
filter_score: ${paper.filterScore}
---`;

  const content = `
# ${paper.title}

> ğŸ“„ Paper: [arXiv](${paper.arxivUrl}) | [PDF](${paper.pdfUrl})
${paper.github ? `> ğŸ’» Code: [GitHub](${paper.github})` : ''}
> ğŸ¤– This article is automatically curated by AI. Content is for reference only.

---

## Why This Paper Was Selected

${paper.filterReason}

**Relevance Score**: ${paper.filterScore}/10

---

${paper.summary_en || '## Abstract\n\n' + paper.summary}

---

## Paper Information

- **arXiv ID**: ${paper.arxivId}
- **Published**: ${paper.published}
- **Updated**: ${paper.updated}
- **Categories**: ${paper.categories.join(', ')}
- **Authors**: ${paper.authors.join(', ')}

---

*Auto-generated by AI Agent on ${new Date().toISOString().split('T')[0]}. Please refer to the original paper for accurate information.*
`;

  return frontmatter + '\n' + content;
}

/**
 * ä¿å­˜Markdownæ–‡ä»¶
 */
export function savePaperAsMarkdown(paper) {
  const slug = generateSlug(paper.title, paper.arxivId);
  const outputDir = path.join(__dirname, '../../', config.output.directory);

  // ç¡®ä¿è¾“å‡ºç›®å½•å­˜åœ¨
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  const filePathZh = path.join(outputDir, `${slug}.zh.md`);
  const filePathEn = path.join(outputDir, `${slug}.en.md`);

  // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å·²å­˜åœ¨
  if (fs.existsSync(filePathZh) || fs.existsSync(filePathEn)) {
    console.log(`âš ï¸  æ–‡ä»¶å·²å­˜åœ¨ï¼Œè·³è¿‡: ${slug}`);
    return null;
  }

  try {
    // ç”Ÿæˆå¹¶ä¿å­˜ä¸­æ–‡ç‰ˆæœ¬
    const contentZh = generateChineseMarkdown(paper);
    fs.writeFileSync(filePathZh, contentZh, 'utf8');
    console.log(`âœ… å·²ä¿å­˜ä¸­æ–‡ç‰ˆæœ¬: ${filePathZh}`);

    // ç”Ÿæˆå¹¶ä¿å­˜è‹±æ–‡ç‰ˆæœ¬
    if (config.output.generateEnglishVersion) {
      const contentEn = generateEnglishMarkdown(paper);
      fs.writeFileSync(filePathEn, contentEn, 'utf8');
      console.log(`âœ… å·²ä¿å­˜è‹±æ–‡ç‰ˆæœ¬: ${filePathEn}`);
    }

    return {
      slug,
      filePathZh,
      filePathEn: config.output.generateEnglishVersion ? filePathEn : null
    };
  } catch (error) {
    console.error(`âŒ ä¿å­˜æ–‡ä»¶å¤±è´¥ ${slug}:`, error.message);
    throw error;
  }
}

/**
 * æ‰¹é‡ä¿å­˜è®ºæ–‡
 */
export function savePapersAsMarkdown(papers) {
  console.log(`\nğŸ“ å¼€å§‹ç”Ÿæˆ ${papers.length} ç¯‡è®ºæ–‡çš„Markdownæ–‡ä»¶...\n`);

  const savedFiles = [];

  for (const paper of papers) {
    try {
      const result = savePaperAsMarkdown(paper);
      if (result) {
        savedFiles.push(result);
      }
    } catch (error) {
      console.error(`è·³è¿‡è®ºæ–‡ ${paper.arxivId}: ${error.message}`);
    }
  }

  console.log(`\nâœ… æˆåŠŸç”Ÿæˆ ${savedFiles.length} ç¯‡è®ºæ–‡çš„Markdownæ–‡ä»¶\n`);

  return savedFiles;
}

/**
 * ç”Ÿæˆæ€»ç»“æŠ¥å‘Š
 */
export function generateReport(papers, savedFiles) {
  const report = `
# AI Agent è¿è¡ŒæŠ¥å‘Š

**è¿è¡Œæ—¶é—´**: ${new Date().toISOString()}

## ç»Ÿè®¡ä¿¡æ¯

- **ç­›é€‰è®ºæ–‡æ•°**: ${papers.length}
- **ç”Ÿæˆæ–‡ä»¶æ•°**: ${savedFiles.length}

## è®ºæ–‡åˆ—è¡¨

${papers.map((paper, i) => `
### ${i + 1}. ${paper.title}

- **arXiv ID**: ${paper.arxivId}
- **è¯„åˆ†**: ${paper.filterScore}/10
- **ç†ç”±**: ${paper.filterReason}
- **æ ‡ç­¾**: ${paper.suggestedTags.join(', ')}
- **é“¾æ¥**: ${paper.arxivUrl}
`).join('\n')}

## ç”Ÿæˆçš„æ–‡ä»¶

${savedFiles.map(file => `- ${file.slug}\n  - ä¸­æ–‡: ${file.filePathZh}\n  - è‹±æ–‡: ${file.filePathEn || 'N/A'}`).join('\n')}

---

*ç”± AI Agent è‡ªåŠ¨ç”Ÿæˆ*
`;

  return report;
}

/**
 * æµ‹è¯•å‡½æ•°
 */
export function testGenerator() {
  console.log('ğŸ§ª æµ‹è¯• Markdown Generator...\n');

  const mockPaper = {
    arxivId: '2404.12345',
    title: 'Test Paper: Video Understanding with LLMs',
    summary: 'This is a test paper about video understanding using large language models.',
    authors: ['John Doe', 'Jane Smith'],
    categories: ['cs.CV', 'cs.AI'],
    published: '2024-04-15',
    updated: '2024-04-16',
    arxivUrl: 'https://arxiv.org/abs/2404.12345',
    pdfUrl: 'https://arxiv.org/pdf/2404.12345.pdf',
    filterScore: 9,
    filterReason: 'è¯¥è®ºæ–‡ç›´æ¥è§£å†³è§†é¢‘ç†è§£é—®é¢˜ï¼Œä½¿ç”¨å¤§è¯­è¨€æ¨¡å‹è¿›è¡Œå¤šæ¨¡æ€å­¦ä¹ ',
    suggestedTags: ['è§†é¢‘ç†è§£', 'å¤šæ¨¡æ€', 'LLM'],
    summary_zh: '## æ ¸å¿ƒåˆ›æ–°\n\nè¿™æ˜¯ä¸€ä¸ªæµ‹è¯•æ€»ç»“...'
  };

  try {
    const result = savePaperAsMarkdown(mockPaper);
    console.log('\nâœ… æµ‹è¯•æˆåŠŸ');
    console.log('ç”Ÿæˆçš„æ–‡ä»¶:', result);
  } catch (error) {
    console.error('\nâŒ æµ‹è¯•å¤±è´¥:', error.message);
  }
}

// å¦‚æœç›´æ¥è¿è¡Œæ­¤æ–‡ä»¶ï¼Œæ‰§è¡Œæµ‹è¯•
if (import.meta.url === `file://${process.argv[1]}`) {
  testGenerator();
}
